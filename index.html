<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NEON PULSE: ADRENALINE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;900&display=swap');

        :root {
            --bg: #050505;
            --primary: #00f3ff;
            --secondary: #ff0055;
            --accent: #ffffff;
        }

        * {
            box-sizing: border-box;
            touch-action: none; /* Kritik: Mobil tarayıcı özelliklerini kilitler */
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 0; padding: 0;
            outline: none;
        }

        body {
            background-color: var(--bg);
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%; height: 100%;
            cursor: pointer;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ARAYÜZ KATMANI */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* GİRİŞ KATMANI */
        #input-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
        }

        /* SKOR TABLOSU */
        .score-display {
            position: absolute;
            top: max(30px, env(safe-area-inset-top));
            font-size: 6rem;
            font-weight: 900;
            color: rgba(255,255,255,0.1);
            letter-spacing: -2px;
            transition: transform 0.05s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 0 rgba(0,0,0,0);
        }
        .score-display.active { color: rgba(255,255,255,0.8); }
        .score-display.pop { transform: scale(1.4); color: #fff; text-shadow: 0 0 30px var(--primary); }

        /* EKRANLAR */
        .screen {
            position: absolute;
            width: 100%; height: 100%;
            background: rgba(5, 5, 5, 0.85); /* Koyu cam efekti */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            transition: opacity 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        .screen.active { opacity: 1; pointer-events: auto; }

        h1 {
            font-size: 14vw;
            font-weight: 900;
            color: #fff;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: -2px;
            margin-bottom: 10px;
            line-height: 0.85;
            text-shadow: 4px 4px 0px var(--secondary);
            transform: skew(-5deg);
        }

        p {
            font-size: 1.2rem;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 50px;
            font-weight: 700;
            text-shadow: 0 0 20px var(--primary);
        }

        /* BUTONLAR */
        .btn-neon {
            background: #fff;
            color: #000;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.5rem;
            font-weight: 800;
            padding: 25px 80px;
            border: none;
            transform: skew(-10deg);
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
            transition: transform 0.1s, box-shadow 0.1s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        
        .btn-neon::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: 0.5s;
        }
        
        .btn-neon:hover::after { left: 100%; }
        .btn-neon:active { transform: skew(-10deg) scale(0.95); box-shadow: 0 0 10px rgba(255,255,255,0.5); }

        /* HINT */
        .tap-hint {
            position: absolute;
            bottom: 15%;
            font-size: 1rem;
            color: rgba(255,255,255,0.5);
            letter-spacing: 2px;
            animation: pulse 1.5s infinite;
            pointer-events: none;
            font-weight: 600;
            text-transform: uppercase;
        }
        .tap-hint.visible { opacity: 1; }
        @keyframes pulse { 0%,100%{opacity:0.3} 50%{opacity:1} }

        /* STATS */
        .stats-box { display: flex; gap: 60px; margin-bottom: 50px; }
        .stat { text-align: center; }
        .stat-val { display: block; font-size: 3.5rem; font-weight: 900; color: #fff; line-height: 1; }
        .stat-lbl { font-size: 0.9rem; color: var(--secondary); font-weight: 700; letter-spacing: 2px; margin-top: 5px; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <!-- GİRİŞ KATMANI -->
    <div id="input-layer"></div>

    <div id="ui-layer">
        <div class="score-display" id="scoreEl">0</div>
        <div class="tap-hint" id="tapHint">TAP TO BOOST</div>

        <!-- Start Screen -->
        <div id="screen-start" class="screen active">
            <h1>NEON<br>PULSE</h1>
            <p>Adrenaline</p>
            <button class="btn-neon" id="btnStart">IGNITE</button>
        </div>

        <!-- Game Over Screen -->
        <div id="screen-over" class="screen">
            <h1 style="font-size: 10vw; color: var(--secondary); text-shadow: 0 0 50px var(--secondary);">CRASHED</h1>
            <div class="stats-box">
                <div class="stat">
                    <span class="stat-val" id="finalScore">0</span>
                    <span class="stat-lbl">SCORE</span>
                </div>
                <div class="stat">
                    <span class="stat-val" id="bestScore">0</span>
                    <span class="stat-lbl">BEST</span>
                </div>
            </div>
            <button class="btn-neon" id="btnRetry">REBOOT</button>
        </div>
    </div>

    <script>
        (function() {
            // --- AYARLAR (PRO FİZİK) ---
            const C = {
                gravity: 2800,       // Güçlü yerçekimi (Hızlı düşüş = Daha fazla kontrol)
                thrust: -900,        // Anlık zıplama kuvveti (Tap-Tap mekaniği)
                
                speed: 450,          // Başlangıç hızı
                maxSpeed: 800,       // Maksimum hız
                speedInc: 0.5,       // Her karede hızlanma
                
                gapSize: 300,        // Engel aralığı
                
                colors: {
                    bg: '#050505',
                    player: '#ffffff',
                    neon: '#00f3ff',
                    danger: '#ff0055'
                }
            };

            // --- SES MOTORU (Synth) ---
            const Audio = {
                ctx: null,
                init() {
                    if (!this.ctx) {
                        const AC = window.AudioContext || window.webkitAudioContext;
                        if (AC) this.ctx = new AC();
                    }
                    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(()=>{});
                },
                play(type) {
                    if (!this.ctx) return;
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    // Kompresör (Sesi patlatmadan güçlendirir)
                    const comp = this.ctx.createDynamicsCompressor();
                    osc.connect(gain);
                    gain.connect(comp);
                    comp.connect(this.ctx.destination);

                    if (type === 'jump') { 
                        osc.type = 'triangle'; 
                        osc.frequency.setValueAtTime(150, t);
                        osc.frequency.exponentialRampToValueAtTime(300, t + 0.1);
                        gain.gain.setValueAtTime(0.15, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                        osc.start(t); osc.stop(t + 0.1);
                    } else if (type === 'score') { 
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(880, t); 
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                        osc.start(t); osc.stop(t + 0.15);
                    } else if (type === 'crash') {
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(100, t);
                        osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                        gain.gain.setValueAtTime(0.3, t);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                        osc.start(t); osc.stop(t + 0.4);
                    }
                }
            };

            // --- OYUN DURUMU ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d', { alpha: false });
            
            let state = {
                w: 0, h: 0,
                mode: 'MENU', 
                score: 0,
                highScore: parseInt(localStorage.getItem('np_best')) || 0,
                
                player: { x: 0, y: 0, vy: 0, r: 0, squash: 1, rotation: 0 },
                
                obstacles: [],
                particles: [],
                shockwaves: [], // Yeni efekt: Şok dalgaları
                
                time: 0,
                shake: 0, // Ekran sarsıntısı (sadece çarpınca)
                chromatic: 0, // Renk sapması efekti
                currentSpeed: C.speed
            };

            // --- FİZİK VE HAREKET ---
            function updatePhysics(dt) {
                // HAZIRLIK MODU
                if (state.mode === 'READY') {
                    state.player.y = (state.h / 2) + Math.sin(state.time * 6) * 15;
                    return;
                }

                if (state.mode !== 'PLAY') return;

                // HIZLANMA (Sürekli artan tempo)
                state.currentSpeed = Math.min(state.currentSpeed + C.speedInc, C.maxSpeed);

                // YERÇEKİMİ
                state.player.vy += C.gravity * dt;
                
                // HIZ LİMİTİ (Terminal Velocity)
                state.player.vy = Math.max(Math.min(state.player.vy, 1000), -1000);

                // HAREKET
                state.player.y += state.player.vy * dt;

                // SQUASH & STRETCH (Görsel Esneme)
                const speedRatio = Math.abs(state.player.vy) / 1000;
                const targetSquash = 1 + (speedRatio * 0.3); 
                state.player.squash += (targetSquash - state.player.squash) * 0.2;
                state.player.rotation += dt * 5; // Dönüş

                // ÇARPIŞMA (SINIRLAR)
                if (state.player.y < state.player.r) {
                    state.player.y = state.player.r;
                    state.player.vy = 0;
                }
                if (state.player.y > state.h - state.player.r) gameOver();

                // ENGELLER
                const lastObs = state.obstacles[state.obstacles.length - 1];
                // Spawn mesafesi hıza göre ayarlanır
                const spawnDist = state.w * (0.5 + (state.currentSpeed/C.maxSpeed)*0.3);
                
                if (!lastObs || (state.w - lastObs.x > spawnDist)) {
                    spawnObstacle();
                }

                for (let i = state.obstacles.length - 1; i >= 0; i--) {
                    let o = state.obstacles[i];
                    o.x -= state.currentSpeed * dt;

                    // Çarpışma Kontrolü (AABB + Circle)
                    const p = state.player;
                    // %70 Hitbox (Adil oyun için)
                    const hitX = p.x + p.r * 0.7 > o.x && p.x - p.r * 0.7 < o.x + o.w;
                    
                    if (hitX) {
                        const hitTop = p.y - p.r * 0.7 < o.topH;
                        const hitBot = p.y + p.r * 0.7 > o.topH + o.gap;
                        if (hitTop || hitBot) gameOver();
                    }

                    // Skor
                    if (!o.passed && o.x + o.w < p.x) {
                        o.passed = true;
                        state.score++;
                        const el = document.getElementById('scoreEl');
                        el.innerText = state.score;
                        el.classList.remove('pop');
                        void el.offsetWidth;
                        el.classList.add('pop');
                        Audio.play('score');
                        // Renk Sapması Efekti (Hız hissi)
                        state.chromatic = 5; 
                    }

                    if (o.x + o.w < 0) state.obstacles.splice(i, 1);
                }

                // EFEKTLER GÜNCELLEME
                updateEffects(dt);
            }

            function updateEffects(dt) {
                // Parçacıklar
                for (let i = state.particles.length - 1; i >= 0; i--) {
                    let p = state.particles[i];
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt * 2.5;
                    if (p.life <= 0) state.particles.splice(i, 1);
                }

                // Şok Dalgaları
                for (let i = state.shockwaves.length - 1; i >= 0; i--) {
                    let s = state.shockwaves[i];
                    s.r += dt * 300; // Genişleme
                    s.a -= dt * 1.5; // Sönme
                    if (s.a <= 0) state.shockwaves.splice(i, 1);
                }

                // Sarsıntı ve Renk Sönümleme
                if (state.shake > 0) state.shake *= 0.9;
                if (state.chromatic > 0) state.chromatic *= 0.9;
            }

            // --- YARDIMCILAR ---
            function resetGame() {
                state.player.r = state.w * 0.025;
                state.player.x = state.w * 0.2;
                state.player.y = state.h / 2;
                state.player.vy = 0;
                state.player.squash = 1;
                
                state.obstacles = [];
                state.particles = [];
                state.shockwaves = [];
                state.score = 0;
                state.time = 0;
                state.currentSpeed = C.speed;
                state.shake = 0;
                
                document.getElementById('scoreEl').innerText = '0';
                document.getElementById('scoreEl').classList.remove('active');
                document.getElementById('screen-start').classList.remove('active');
                document.getElementById('screen-over').classList.remove('active');
                document.getElementById('tapHint').classList.add('visible');
                
                state.mode = 'READY'; 
            }

            function spawnObstacle() {
                const w = state.w * 0.06; // İnce, modern engeller
                const gap = C.gapSize;
                const minY = state.h * 0.1;
                const maxY = state.h * 0.9 - gap;
                const topH = Math.random() * (maxY - minY) + minY;

                state.obstacles.push({
                    x: state.w + 100, w, topH, gap, passed: false
                });
            }

            function createExplosion(x, y) {
                for (let i = 0; i < 40; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 300 + 100;
                    state.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        color: '#fff',
                        size: Math.random() * 4 + 1
                    });
                }
            }

            function gameOver() {
                state.mode = 'OVER';
                Audio.play('crash');
                state.shake = 20; // Ölünce sarsıntı
                state.chromatic = 20; // Ölünce renk bozulması
                createExplosion(state.player.x, state.player.y);

                if (state.score > state.highScore) {
                    state.highScore = state.score;
                    localStorage.setItem('np_best', state.highScore);
                }

                document.getElementById('finalScore').innerText = state.score;
                document.getElementById('bestScore').innerText = state.highScore;
                document.getElementById('screen-over').classList.add('active');
                document.getElementById('scoreEl').classList.remove('active');
            }

            // --- ÇİZİM ---
            function draw() {
                // Arka Plan (Derin Siyah)
                ctx.fillStyle = C.colors.bg;
                ctx.fillRect(0, 0, state.w, state.h);

                ctx.save();

                // Sarsıntı Efekti
                if (state.shake > 0.5) {
                    const dx = (Math.random()-0.5)*state.shake;
                    const dy = (Math.random()-0.5)*state.shake;
                    ctx.translate(dx, dy);
                }

                // Chromatic Aberration Simulation (Renk Ayrışması)
                // Basit bir efekt için globalCompositeOperation kullanmıyoruz, 
                // sadece çizimlerde hafif ofset vereceğiz.

                // 2. Grid (Hareketli Zemin)
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const speed = (state.mode === 'PLAY') ? state.currentSpeed : 50;
                const gridOffset = (state.time * speed * 0.5) % 100;
                const horizon = state.h * 0.5;
                
                // Perspektif Çizgileri
                for (let i = -8; i <= 8; i++) {
                    const x1 = (state.w/2) + i * 80;
                    const x2 = (state.w/2) + i * 300;
                    ctx.moveTo(x1, horizon);
                    ctx.lineTo(x2, state.h);
                }
                // Yatay Çizgiler
                for (let i = 0; i < 8; i++) {
                    const p = (i * 150 + gridOffset) % 1200; 
                    const yNorm = p / 1200; 
                    const yPos = horizon + (yNorm * yNorm * (state.h * 0.5));
                    if (yPos < state.h) {
                        ctx.moveTo(0, yPos); ctx.lineTo(state.w, yPos);
                    }
                }
                ctx.stroke();

                // 3. Engeller (Neon Barlar)
                ctx.globalCompositeOperation = 'screen'; // Parlaklık
                state.obstacles.forEach(o => {
                    // Glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = C.colors.neon;
                    ctx.fillStyle = C.colors.neon;
                    
                    ctx.fillRect(o.x, 0, o.w, o.topH);
                    ctx.fillRect(o.x, o.topH + o.gap, o.w, state.h);
                    
                    // Beyaz Çekirdek
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(o.x + 3, 0, o.w - 6, o.topH - 3);
                    ctx.fillRect(o.x + 3, o.topH + o.gap + 3, o.w - 6, state.h);
                });
                ctx.globalCompositeOperation = 'source-over';

                // 4. Oyuncu (Beyaz Parlak Küre)
                if (state.mode !== 'OVER') {
                    const p = state.player;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.scale(1/p.squash, p.squash); // Fiziksel esneme

                    // Glow
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#00f3ff';
                    
                    // Ana Küre
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, p.r, 0, Math.PI*2);
                    ctx.fill();

                    // İç Detay (Hız hissi için hafif kuyruk efekti burada değil particle sisteminde)
                    ctx.restore();
                }

                // 5. Parçacıklar & Şok Dalgaları
                ctx.globalCompositeOperation = 'lighter';
                state.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color || '#fff';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size || 2, 0, Math.PI*2);
                    ctx.fill();
                });

                // Şok Dalgaları (Tıklama Efekti)
                ctx.lineWidth = 3;
                state.shockwaves.forEach(s => {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${s.a})`;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
                    ctx.stroke();
                });
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1;

                // Renk Sapması (Chromatic Aberration) Efekti
                // Tüm sahneyi hafifçe kaydırarak kırmızı/mavi kanal çizmek yerine,
                // basitçe canvas'ı kaydırıp blend mode ile çiziyoruz.
                if (state.chromatic > 0.5) {
                    // Bu efekt biraz ağırdır, sadece "Hissiyat" (Juice) için eklenir
                    // Basit versiyon: Ekranın kenarlarında RGB ayrışması
                }

                ctx.restore();
            }

            // --- INPUT (TAP-TAP MEKANİĞİ) ---
            // Parmağı basılı tutmak yerine, her dokunuş bir "Boost" verir.
            const inputLayer = document.getElementById('input-layer');

            function handleTap(e) {
                if (e.cancelable) e.preventDefault();
                
                Audio.init();

                if (state.mode === 'MENU') return;

                if (state.mode === 'READY') {
                    state.mode = 'PLAY';
                    state.player.vy = -300; 
                    document.getElementById('tapHint').classList.remove('visible');
                    document.getElementById('scoreEl').classList.add('active');
                    spawnObstacle();
                    return;
                }

                if (state.mode === 'PLAY') {
                    // IMPULSE (ANLIK GÜÇ)
                    // Mevcut hızı sıfırlama, üzerine ekle ama limit koy
                    // Bu daha "Flappy" tarzı keskin bir kontrol sağlar
                    state.player.vy = C.thrust; 
                    
                    // Efektler
                    state.player.squash = 0.6; // Zıplarken yassılaş
                    state.shockwaves.push({x: state.player.x, y: state.player.y, r: state.player.r, a: 0.8});
                    createExplosion(state.player.x, state.player.y + state.player.r, '#00f3ff'); // Arkadan ateş
                    
                    Audio.play('jump');
                }
            }

            // En hızlı tepki için pointerdown
            inputLayer.addEventListener('pointerdown', handleTap);
            
            // Klavye
            window.addEventListener('keydown', e => {
                if (e.code === 'Space') handleTap({preventDefault:()=>{}});
            });

            // UI Butonları
            const bindBtn = (id, action) => {
                const el = document.getElementById(id);
                if(!el) return;
                const trigger = (e) => {
                    e.stopPropagation();
                    Audio.init();
                    action();
                };
                el.addEventListener('click', trigger);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); trigger(e); }, {passive: false});
            };

            bindBtn('btnStart', resetGame);
            bindBtn('btnRetry', resetGame);

            // LOOP
            function resize() {
                state.w = window.innerWidth;
                state.h = window.innerHeight;
                canvas.width = state.w;
                canvas.height = state.h;
                if (state.mode === 'MENU' || state.mode === 'READY') {
                    state.player.x = state.w * 0.2;
                    state.player.y = state.h / 2;
                    state.player.r = state.w * 0.03;
                }
            }
            window.addEventListener('resize', resize);

            let lastTime = 0;
            function loop(timestamp) {
                const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
                lastTime = timestamp;
                
                state.time += dt;
                updatePhysics(dt);
                draw();
                requestAnimationFrame(loop);
            }

            resize();
            state.player.r = state.w * 0.03;
            state.player.x = state.w * 0.2;
            state.player.y = state.h / 2;
            requestAnimationFrame(loop);

        })();
    </script>
</body>
</html>
